---
layout: post
title: "The Ultra-Modernist Allure of Esoteric Programming Languages (Esolangs)"
description: ""
comments: true
keywords: "programming, software, coding, engineering, esoteric, language, esolang"
---

I'll spoil it up front for you guys: the allure of esoteric programming languages, or, colloquially, "esolangs", is one of seeing how far a definition stretches. This, at least from my own observations and experiences, is a natural extension of modernism in art and culture, which itself is perhaps a consequence of a very human sort of curiosity and desire to conceive of and create that which hasn't been conceived of before. The artistic philosophy (of all types - visual, music, literary, etc.) at the turn of the 20th Century and onwards was all about throwing away preconceptions of what art was and letting pure, unfettered inventiveness take over. Of course, whether such inventiveness was done in good taste is surely a topic of contentious debate by scholars and amateurs alike even to this date, with some welcoming the bold contributions of these modernist artists and others rejecting it, often vehemently. In the end, however, it is clear that the modernist movement prompted a wholesale reconsideration of what was or wasn't art. The contemporary avant-garde stretches these definitions further yet.

The existence of esolangs stretch a different definition: that of a programming language. Or does it? Actually, not really. Defining a programming language as a formal language that computers are able to systematically translate into machine language that the computer's hardware "natively" understands is already abstract enough to include some rather strange specimens. In fact, all esolangs for which there exists an interpreter or compiler are programming language by this very definition.

While esolangs don't stretch definitions, they sure do stretch preconceptions. The serious programming language is a beautiful thing; it is an immensely powerful tool that allows us, through a series of beautiful abstractions and the ability to create even more user-defined abstractions in the language (such as objects), to systematically instruct the complex electronic whirlwinds inside of all of the world's computing machines to perform the society-altering tasks that we all rely on everyday. It is something that all can agree to appreciate, like the _Mona Lisa_ or a Beethoven symphony. Yet, the esolang is often intentionally obfuscatory, ugly, and inconvenient. These languages are more commonly appreciated for the creativity required to come up with something so strange as opposed to the skill required to design them (not to say that there aren't skillfully designed esolangs) and can be compared perhaps more closely to, say, Dali's _Lobster Telephone_ or John Cage's _4'33"_.

Consider, for example, [MarioLANG](https://esolangs.org/wiki/MarioLANG). The idea of a Turing-complete language whose code visually mirrors that of a Super Mario stage is already quite egregious, if not comedic. The other aspect of the esolang's allure, I feel, comes with the implementation of such ideas: the absurdist humor of recognizing an idea's comedic, useless, and impractical intent and saying "screw it" to that and taking often long periods of time to bring these ideas into fruition. This is the difference between, for example, Satie writing down his _Vexations_ and instructing a hypothetical player to perform it 840 times and an actual performance of the piece. The ironic juxtaposition of how little time it took Satie to write down the number "840" and how impactful the large number was on the fates of performers of his _Vexations_, I think, captures the comedic flavor of realizing a ridiculous esolang.

A few more interesting joke esolangs for your entertainment:

- [42](https://esolangs.org/wiki/42)
- [Entropy](https://esolangs.org/wiki/Entropy)
- [Lenguage](https://esolangs.org/wiki/Lenguage)
- [Magritte](https://esolangs.org/wiki/Magritte), which suits the modernist theme of this post quite well
- [Ook!](https://esolangs.org/wiki/Ook!)
- [Unnecessary](https://esolangs.org/wiki/Unnecessary)

My own esolang that I recently (as of writing this post) finished implementing:

- [RubikTreeLang](https://github.com/alanjding/RubikTreeLang)

A couple of my own ideas that might warrant implementation in the future:

- TrackWorkout - something that maps a track workout (reps/length/rest/pace) to some sort of executable
- J A Z Z - something that maps chord progressions or even chords (root note, extensions, altered notes, voicing, duration) to some sort of executable
